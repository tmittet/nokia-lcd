/************************************************************************/
/* Driver for the Nokia Graphic LCD 84x48, v1.0.                        */
/* Based on library written by Sylvain Bissonnette and Louis Frigon:    */
/* http://www.microsyl.com/index.php/2010/03/24/nokia-lcd-library/      */
/*                                                                      */
/* This library is free software: you can redistribute it and/or modify */
/* it under the terms of the GNU General Public License as published by */
/* the Free Software Foundation, either version 3 of the License, or    */
/* (at your option) any later version.                                  */
/*                                                                      */
/* This library is distributed in the hope that it will be useful, but  */
/* WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU     */
/* General Public License for more details.                             */
/*                                                                      */
/* You should have received a copy of the GNU General Public License    */
/* along with this library. If not, see <http://www.gnu.org/licenses/>. */
/*                                                                      */
/* Written by Thomas Mittet thomas@mittet.nu September 2011.            */
/************************************************************************/

#include "WProgram.h"
#include "NokiaLCD.h"

const uint8_t NokiaLCD::FONT[96][5] =
{
   {0x00, 0x00, 0x00, 0x00, 0x00} // Space
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // Backslash
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // j 
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // p
  ,{0x08, 0x14, 0x14, 0x14, 0x7c} // q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // ~
  ,{0x7f, 0x7f, 0x7f, 0x7f, 0x7f} // Block
};

NokiaLCD::NokiaLCD(uint8_t clockPin, uint8_t dataPin, uint8_t modeSelectPin, uint8_t dataSelectPin, uint8_t resetPin)
{
  this->clockPin = clockPin;
  this->dataPin = dataPin;
  this->modeSelectPin = modeSelectPin;
  this->dataSelectPin = dataSelectPin;
  this->resetPin = resetPin;
}

//////////////////////////////
/// Public
//////////////////////////////

void NokiaLCD::begin()
{
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);
  pinMode(modeSelectPin, OUTPUT);
  pinMode(dataSelectPin, OUTPUT);
  pinMode(resetPin, OUTPUT);
  // Send reset signal to init display chip
  digitalWrite(resetPin, LOW);
  digitalWrite(resetPin, HIGH);
  // Enable data receive
  digitalWrite(dataSelectPin, DATA_ENABLED);
  // Set LCD to command mode
  digitalWrite(modeSelectPin, MODE_COMMAND);
  // Set extended commands
  write(CHIP_CMD_EXTENDED);
  write(TEMP_COEFFICIENT_2);
  // Set basic commands
  write(CHIP_CMD_BASIC_H);
  write(DISP_CONF_NORMAL);
  // Set LCD to data mode
  digitalWrite(modeSelectPin, MODE_DATA);
  // Reset cursor position and clear display
  clear();
}

void NokiaLCD::clear(void)
{
  setCursor();
  for (int i = 0; i < LCD_WIDTH * LCD_HEIGHT / FONT_HEIGHT; i++)
  {
    write(0x00);
  }
}

void NokiaLCD::setCursor(uint8_t line, uint8_t column)
{
  line--;
  column--;
  if (line > 5) line = 0;
  if (column > 13) column = 0;
  digitalWrite(modeSelectPin, MODE_COMMAND);
  write(RAM_ADDRESS_Y | line);
  write(RAM_ADDRESS_X | (column * FONT_WIDTH));
  digitalWrite(modeSelectPin, MODE_DATA);
}

void NokiaLCD::writeCharacter(uint8_t character)
{
  // Write font
  for (int i = 0; i < 5; i++)
  {
    write(FONT[character - 0x20][i]);
  }
  // Write 1 x 8 px whitespace after character
  // to leave some space between letters
  // Spacing below characters is taken care
  // of by font matrix, pixel 8 is never used
  write(0x00);
}

void NokiaLCD::writeLine(char *line, bool crLf)
{
  uint8_t cols = 0;
  while (*line)
  {
    writeCharacter(*line++);
    cols += FONT_WIDTH;
  }
  // Fill rest of line with whitespace if
  // there are not enough characters.
  if (crLf && (cols %= LCD_WIDTH))
  {
    while (LCD_WIDTH > cols)
    {
      write(0x00);
      cols++;
    }
  }
}

//////////////////////////////
/// Private
//////////////////////////////

void NokiaLCD::write(uint8_t data)
{
  shiftOut(dataPin, clockPin, MSBFIRST, data);
}